{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nimport throttle from 'lodash.throttle';\nimport warn from 'warning';\nimport Node from './GraphNode';\nimport { instancedExt, MaterialNode } from '.';\nimport { PointLights } from '../lights';\nimport { CameraNode } from './CameraNode';\nimport { GeometryNode } from './GeometryNode';\nimport { InstancedNode } from './InstancedNode';\nexport var isSceneNode = Symbol('isSceneNode');\nfunction getMode(gl, modeString) {\n  if (!modeString) {\n    return gl.TRIANGLES;\n  }\n  switch (modeString) {\n    case 'TRIANGLES':\n      return gl.TRIANGLES;\n    case 'LINES':\n      return gl.LINES;\n    case 'POINTS':\n      return gl.POINTS;\n    case 'LINE_STRIP':\n      return gl.LINE_STRIP;\n    case 'LINE_LOOP':\n      return gl.LINE_LOOP;\n    case 'TRIANGLE_STRIP':\n      return gl.TRIANGLE_STRIP;\n    case 'TRIANGLE_FAN':\n      return gl.TRIANGLE_FAN;\n    default:\n      return gl.TRIANGLES;\n  }\n}\nexport var SceneNode = /*#__PURE__*/function (_Node) {\n  _inherits(SceneNode, _Node);\n  var _super = _createSuper(SceneNode);\n  function SceneNode(canvas, extensions, _gl) {\n    var _this;\n    _classCallCheck(this, SceneNode);\n    _this = _super.call(this);\n    _this.context = void 0;\n    _this.element = void 0;\n    _this.maxTextures = void 0;\n    _this.extensions = void 0;\n    _this[isSceneNode] = true;\n    _this.renderOnUpdate = false;\n    _this.webglVersion = 1;\n    _this.pointLights = new PointLights();\n    _this.clearColor = [0, 0, 0, 0];\n    _this.textureUnits = {};\n    _this.materialMap = new WeakMap();\n    _this.activeAttribCount = 0;\n    _this.activeAttributes = null;\n    _this.render = function () {\n      var gl = _this.context;\n      gl.enable(gl.DEPTH_TEST);\n      gl.clearColor.apply(gl, _toConsumableArray(_this.clearColor));\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n      Object.keys(_this.textureUnits).forEach(function (unit) {\n        if (_this.textureUnits[unit] !== false) {\n          /* @ts-ignore */\n          gl.activeTexture(gl[\"TEXTURE\".concat(unit)]);\n          gl.bindTexture(gl.TEXTURE_2D, _this.textureUnits[unit]);\n        }\n      });\n      var needsMatrixUpdate = _this.needsMatrixUpdate === true;\n      if (needsMatrixUpdate) {\n        _this.updateMatrix();\n        _this.updateWorldMatrix();\n        _this.needsMatrixUpdate = false;\n      }\n      for (var i = 0; i < _this.children.length; i++) {\n        _this.renderNode(_this.children[i], null, null, needsMatrixUpdate);\n      }\n    };\n    _this.requestRender = throttle(_this.render, 17);\n    _this.context = _gl;\n    _this.element = canvas;\n    _this.maxTextures = _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS);\n    _this.extensions = extensions.reduce(function (acc, ext) {\n      acc[ext] = _gl.getExtension(ext);\n      return acc;\n    }, {});\n    return _this;\n  }\n  _createClass(SceneNode, [{\n    key: \"getTextureUnit\",\n    value: function getTextureUnit(texture) {\n      for (var _unit = 0; _unit < this.maxTextures; _unit++) {\n        if (this.textureUnits[_unit] === undefined) {\n          this.textureUnits[_unit] = texture || false;\n          return _unit;\n        }\n      }\n      warn(false, \"Max textures(\".concat(this.maxTextures, \") exceeded.\"));\n      return this.maxTextures - 1;\n    }\n  }, {\n    key: \"releaseTextureUnit\",\n    value: function releaseTextureUnit(unit) {\n      delete this.textureUnits[unit];\n    }\n  }, {\n    key: \"setMaterial\",\n    value: function setMaterial(gl, _ref) {\n      var program = _ref.program;\n      if (!program) {\n        throw Error('Encountered material with no program.');\n      }\n      var material = this.materialMap.get(program);\n      if (material) {\n        return material;\n      }\n      var attributes = {};\n      var attribCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n      for (var i = attribCount - 1; i >= 0; i--) {\n        var attr = gl.getActiveAttrib(program, i);\n        if (attr) {\n          attributes[attr.name] = gl.getAttribLocation(program, attr.name);\n        } else {\n          warn(false, 'Encountered invalid attribute index.');\n        }\n      }\n      var uniforms = {\n        v: gl.getUniformLocation(program, 'viewMatrix'),\n        m: gl.getUniformLocation(program, 'modelMatrix'),\n        p: gl.getUniformLocation(program, 'projectionMatrix')\n      };\n      material = {\n        program: program,\n        uniforms: uniforms,\n        attributes: attributes,\n        attribCount: attribCount\n      };\n      this.materialMap.set(program, material);\n      return material;\n    }\n  }, {\n    key: \"renderNode\",\n    value: function renderNode(node, activeCamera, activeMaterial, needsMatrixUpdate) {\n      var gl = this.context; // *************************************************\n      // UPDATE MATRIX IF NEEDED\n      // *************************************************\n\n      needsMatrixUpdate = needsMatrixUpdate || node.needsMatrixUpdate === true;\n      if (needsMatrixUpdate) {\n        node.updateMatrix();\n        node.updateWorldMatrix();\n        node.needsMatrixUpdate = false;\n      } // *************************************************\n      // HANDLE CAMERA\n      // *************************************************\n\n      if (node instanceof CameraNode) {\n        activeCamera = node;\n      } // *************************************************\n      // HANDLE MATERIAL\n      // *************************************************\n\n      if (node instanceof MaterialNode) {\n        var nextMaterial = this.setMaterial(gl, node); // note: buffers are deleted when no longer in use by the buffer\n        // hooks. So we to disable attribute indexes no longer in use or it\n        // will throw an error about no buffer being bound to the index.\n\n        var diff = this.activeAttribCount - nextMaterial.attribCount;\n        if (diff > 0) {\n          for (var i = 0; i < diff; i++) {\n            gl.disableVertexAttribArray(nextMaterial.attribCount + i);\n          }\n        }\n        this.activeAttribCount = nextMaterial.attribCount;\n        this.activeAttributes = null;\n        activeMaterial = nextMaterial;\n        gl.useProgram(activeMaterial.program);\n        if (activeCamera) {\n          var _activeCamera = activeCamera,\n            view = _activeCamera.view,\n            projection = _activeCamera.projection;\n          gl.uniformMatrix4fv(activeMaterial.uniforms.v, false, view);\n          gl.uniformMatrix4fv(activeMaterial.uniforms.p, false, projection);\n        }\n      } // *************************************************\n      // HANDLE GEOMETRY\n      // *************************************************\n\n      if (node instanceof GeometryNode) {\n        if (activeMaterial) {\n          gl.useProgram(activeMaterial.program);\n          if (node.attributes !== this.activeAttributes) {\n            for (var attr in activeMaterial.attributes) {\n              var location = activeMaterial.attributes[attr];\n              node.attributes[attr](location);\n            }\n            this.activeAttributes = node.attributes;\n          }\n          gl.uniformMatrix4fv(activeMaterial.uniforms.m, false, node.worldMatrix);\n          if (node.drawArrays) {\n            gl.drawArrays(getMode(gl, node.drawArrays.mode), node.drawArrays.first || 0, node.drawArrays.count);\n          } else if (node.drawElements) {\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node.index);\n            gl.drawElements(getMode(gl, node.drawElements.mode), node.drawElements.count, node.drawElements.type ?\n            // @ts-ignore\n            gl[node.drawElements.type] : gl.UNSIGNED_SHORT, node.drawElements.offset || 0);\n          }\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n          gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        }\n      } // *************************************************\n      // HANDLE INSTANCED GEOMETRY\n      // *************************************************\n\n      if (node instanceof InstancedNode) {\n        if (activeMaterial) {\n          gl.useProgram(activeMaterial.program);\n          if (this.extensions[instancedExt] === undefined) {\n            this.extensions[instancedExt] = gl.getExtension(instancedExt);\n          }\n          var ext = this.extensions[instancedExt];\n          if (node.attributes !== this.activeAttributes) {\n            for (var _attr in activeMaterial.attributes) {\n              var _location = activeMaterial.attributes[_attr];\n              node.attributes[_attr](_location, ext, this.webglVersion);\n            }\n            this.activeAttributes = node.attributes;\n          }\n          gl.uniformMatrix4fv(activeMaterial.uniforms.m, false, node.worldMatrix);\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node.index);\n          if (this.webglVersion === 2 && node.drawElements) {\n            // @ts-ignore\n            gl.drawElementsInstanced(getMode(gl, node.drawElements.mode), node.drawElements.count, node.drawElements.type ?\n            // @ts-ignore\n            gl[node.drawElements.type] : gl.UNSIGNED_SHORT, node.drawElements.offset || 0, node.drawElements.primcount);\n          } else if (node.drawElements) {\n            ext.drawElementsInstancedANGLE(getMode(gl, node.drawElements.mode), node.drawElements.count, node.drawElements.type ?\n            // @ts-ignore\n            gl[node.drawElements.type] : gl.UNSIGNED_SHORT, node.drawElements.offset || 0, node.drawElements.primcount);\n          }\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n          gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        }\n      }\n      for (var _i = 0; _i < node.children.length; _i++) {\n        this.renderNode(node.children[_i], activeCamera, activeMaterial, needsMatrixUpdate);\n      }\n    }\n  }]);\n  return SceneNode;\n}(Node);","map":{"version":3,"names":["throttle","warn","Node","instancedExt","MaterialNode","PointLights","CameraNode","GeometryNode","InstancedNode","isSceneNode","Symbol","getMode","gl","modeString","TRIANGLES","LINES","POINTS","LINE_STRIP","LINE_LOOP","TRIANGLE_STRIP","TRIANGLE_FAN","SceneNode","_Node","_inherits","_super","_createSuper","canvas","extensions","_gl","_this","_classCallCheck","call","context","element","maxTextures","renderOnUpdate","webglVersion","pointLights","clearColor","textureUnits","materialMap","WeakMap","activeAttribCount","activeAttributes","render","enable","DEPTH_TEST","apply","_toConsumableArray","viewport","width","height","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","Object","keys","forEach","unit","activeTexture","concat","bindTexture","TEXTURE_2D","needsMatrixUpdate","updateMatrix","updateWorldMatrix","i","children","length","renderNode","requestRender","getParameter","MAX_TEXTURE_IMAGE_UNITS","reduce","acc","ext","getExtension","_createClass","key","value","getTextureUnit","texture","_unit","undefined","releaseTextureUnit","setMaterial","_ref","program","Error","material","get","attributes","attribCount","getProgramParameter","ACTIVE_ATTRIBUTES","attr","getActiveAttrib","name","getAttribLocation","uniforms","v","getUniformLocation","m","p","set","node","activeCamera","activeMaterial","nextMaterial","diff","disableVertexAttribArray","useProgram","_activeCamera","view","projection","uniformMatrix4fv","location","worldMatrix","drawArrays","mode","first","count","drawElements","bindBuffer","ELEMENT_ARRAY_BUFFER","index","type","UNSIGNED_SHORT","offset","ARRAY_BUFFER","_attr","_location","drawElementsInstanced","primcount","drawElementsInstancedANGLE","_i"],"sources":["/Users/ifeoma/Documents/Documents - Ifeoma’s MacBook Air/Master's/Westcliff/SPRG24/WEB 603 - Full Stack Web Development/full-stack-web-dev-wk-7/Day 1/m6-w7-d1-demo/light-orb-animation-app/node_modules/@react-vertex/core/src/sceneGraph/SceneNode.ts"],"sourcesContent":["import throttle from 'lodash.throttle'\nimport warn from 'warning'\nimport Node from './GraphNode'\nimport { instancedExt, MaterialNode } from '.'\nimport { PointLights } from '../lights'\nimport {\n  GLContext,\n  DrawMode,\n  RenderMaterial,\n  GeometryAttributes,\n} from '../types'\nimport GraphNode from './GraphNode'\nimport { CameraNode } from './CameraNode'\nimport { GeometryNode } from './GeometryNode'\nimport { InstancedNode } from './InstancedNode'\n\nexport const isSceneNode = Symbol('isSceneNode')\n\nfunction getMode(gl: GLContext, modeString: DrawMode) {\n  if (!modeString) {\n    return gl.TRIANGLES\n  }\n\n  switch (modeString) {\n    case 'TRIANGLES':\n      return gl.TRIANGLES\n    case 'LINES':\n      return gl.LINES\n    case 'POINTS':\n      return gl.POINTS\n    case 'LINE_STRIP':\n      return gl.LINE_STRIP\n    case 'LINE_LOOP':\n      return gl.LINE_LOOP\n    case 'TRIANGLE_STRIP':\n      return gl.TRIANGLE_STRIP\n    case 'TRIANGLE_FAN':\n      return gl.TRIANGLE_FAN\n    default:\n      return gl.TRIANGLES\n  }\n}\n\nexport class SceneNode extends Node {\n  context: GLContext\n  element: HTMLCanvasElement\n  maxTextures: number\n  extensions: { [key: string]: any }\n  constructor(canvas: HTMLCanvasElement, extensions: string[], gl: GLContext) {\n    super()\n\n    this.context = gl\n    this.element = canvas\n\n    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)\n\n    this.extensions = extensions.reduce((acc, ext) => {\n      acc[ext] = gl.getExtension(ext)\n      return acc\n    }, {} as any)\n  }\n\n  [isSceneNode] = true\n  renderOnUpdate = false\n  webglVersion = 1\n\n  pointLights = new PointLights()\n  clearColor: number[] = [0, 0, 0, 0]\n\n  textureUnits: { [unit: string]: WebGLTexture | false } = {}\n\n  getTextureUnit(texture?: WebGLTexture | null) {\n    for (let unit = 0; unit < this.maxTextures; unit++) {\n      if (this.textureUnits[unit] === undefined) {\n        this.textureUnits[unit] = texture || false\n        return unit\n      }\n    }\n\n    warn(false, `Max textures(${this.maxTextures}) exceeded.`)\n\n    return this.maxTextures - 1\n  }\n\n  releaseTextureUnit(unit: number) {\n    delete this.textureUnits[unit]\n  }\n\n  materialMap = new WeakMap<WebGLProgram, RenderMaterial>()\n\n  setMaterial(gl: GLContext, { program }: MaterialNode) {\n    if (!program) {\n      throw Error('Encountered material with no program.')\n    }\n\n    let material = this.materialMap.get(program)\n\n    if (material) {\n      return material\n    }\n\n    const attributes: { [name: string]: number } = {}\n\n    const attribCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES)\n\n    for (let i = attribCount - 1; i >= 0; i--) {\n      const attr = gl.getActiveAttrib(program, i)\n\n      if (attr) {\n        attributes[attr.name] = gl.getAttribLocation(program, attr.name)\n      } else {\n        warn(false, 'Encountered invalid attribute index.')\n      }\n    }\n\n    const uniforms = {\n      v: gl.getUniformLocation(program, 'viewMatrix'),\n      m: gl.getUniformLocation(program, 'modelMatrix'),\n      p: gl.getUniformLocation(program, 'projectionMatrix'),\n    }\n\n    material = { program, uniforms, attributes, attribCount }\n\n    this.materialMap.set(program, material)\n\n    return material\n  }\n\n  activeAttribCount = 0\n  activeAttributes: GeometryAttributes | null = null\n\n  render = () => {\n    const gl = this.context\n\n    gl.enable(gl.DEPTH_TEST)\n    gl.clearColor(...(this.clearColor as [number, number, number, number]))\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\n\n    Object.keys(this.textureUnits).forEach(unit => {\n      if (this.textureUnits[unit] !== false) {\n        /* @ts-ignore */\n        gl.activeTexture(gl[`TEXTURE${unit}`])\n        gl.bindTexture(gl.TEXTURE_2D, this.textureUnits[unit])\n      }\n    })\n\n    const needsMatrixUpdate = this.needsMatrixUpdate === true\n\n    if (needsMatrixUpdate) {\n      this.updateMatrix()\n      this.updateWorldMatrix()\n      this.needsMatrixUpdate = false\n    }\n\n    for (let i = 0; i < this.children.length; i++) {\n      this.renderNode(this.children[i], null, null, needsMatrixUpdate)\n    }\n  }\n\n  requestRender: () => void = throttle(this.render, 17)\n\n  renderNode(\n    node: GraphNode,\n    activeCamera: CameraNode | null,\n    activeMaterial: RenderMaterial | null,\n    needsMatrixUpdate: boolean,\n  ) {\n    const gl = this.context\n\n    // *************************************************\n    // UPDATE MATRIX IF NEEDED\n    // *************************************************\n    needsMatrixUpdate = needsMatrixUpdate || node.needsMatrixUpdate === true\n\n    if (needsMatrixUpdate) {\n      node.updateMatrix()\n      node.updateWorldMatrix()\n      node.needsMatrixUpdate = false\n    }\n\n    // *************************************************\n    // HANDLE CAMERA\n    // *************************************************\n\n    if (node instanceof CameraNode) {\n      activeCamera = node\n    }\n\n    // *************************************************\n    // HANDLE MATERIAL\n    // *************************************************\n\n    if (node instanceof MaterialNode) {\n      const nextMaterial = this.setMaterial(gl, node)\n\n      // note: buffers are deleted when no longer in use by the buffer\n      // hooks. So we to disable attribute indexes no longer in use or it\n      // will throw an error about no buffer being bound to the index.\n      const diff = this.activeAttribCount - nextMaterial.attribCount\n\n      if (diff > 0) {\n        for (let i = 0; i < diff; i++) {\n          gl.disableVertexAttribArray(nextMaterial.attribCount + i)\n        }\n      }\n\n      this.activeAttribCount = nextMaterial.attribCount\n      this.activeAttributes = null\n\n      activeMaterial = nextMaterial\n\n      gl.useProgram(activeMaterial.program)\n\n      if (activeCamera) {\n        const { view, projection } = activeCamera\n\n        gl.uniformMatrix4fv(activeMaterial.uniforms.v, false, view)\n        gl.uniformMatrix4fv(activeMaterial.uniforms.p, false, projection)\n      }\n    }\n\n    // *************************************************\n    // HANDLE GEOMETRY\n    // *************************************************\n\n    if (node instanceof GeometryNode) {\n      if (activeMaterial) {\n        gl.useProgram(activeMaterial.program)\n\n        if (node.attributes !== this.activeAttributes) {\n          for (const attr in activeMaterial.attributes) {\n            const location = activeMaterial.attributes[attr]\n            node.attributes[attr](location)\n          }\n\n          this.activeAttributes = node.attributes\n        }\n\n        gl.uniformMatrix4fv(activeMaterial.uniforms.m, false, node.worldMatrix)\n\n        if (node.drawArrays) {\n          gl.drawArrays(\n            getMode(gl, node.drawArrays.mode),\n            node.drawArrays.first || 0,\n            node.drawArrays.count,\n          )\n        } else if (node.drawElements) {\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node.index)\n\n          gl.drawElements(\n            getMode(gl, node.drawElements.mode),\n            node.drawElements.count,\n            node.drawElements.type\n              ? // @ts-ignore\n                gl[node.drawElements.type]\n              : gl.UNSIGNED_SHORT,\n            node.drawElements.offset || 0,\n          )\n        }\n\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)\n        gl.bindBuffer(gl.ARRAY_BUFFER, null)\n      }\n    }\n\n    // *************************************************\n    // HANDLE INSTANCED GEOMETRY\n    // *************************************************\n\n    if (node instanceof InstancedNode) {\n      if (activeMaterial) {\n        gl.useProgram(activeMaterial.program)\n\n        if (this.extensions[instancedExt] === undefined) {\n          this.extensions[instancedExt] = gl.getExtension(instancedExt)\n        }\n\n        const ext = this.extensions[instancedExt]\n\n        if (node.attributes !== this.activeAttributes) {\n          for (const attr in activeMaterial.attributes) {\n            const location = activeMaterial.attributes[attr]\n            node.attributes[attr](location, ext, this.webglVersion)\n          }\n\n          this.activeAttributes = node.attributes\n        }\n\n        gl.uniformMatrix4fv(activeMaterial.uniforms.m, false, node.worldMatrix)\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, node.index)\n\n        if (this.webglVersion === 2 && node.drawElements) {\n          // @ts-ignore\n          gl.drawElementsInstanced(\n            getMode(gl, node.drawElements.mode),\n            node.drawElements.count,\n            node.drawElements.type\n              ? // @ts-ignore\n                gl[node.drawElements.type]\n              : gl.UNSIGNED_SHORT,\n            node.drawElements.offset || 0,\n            node.drawElements.primcount,\n          )\n        } else if (node.drawElements) {\n          ext.drawElementsInstancedANGLE(\n            getMode(gl, node.drawElements.mode),\n            node.drawElements.count,\n            node.drawElements.type\n              ? // @ts-ignore\n                gl[node.drawElements.type]\n              : gl.UNSIGNED_SHORT,\n            node.drawElements.offset || 0,\n            node.drawElements.primcount,\n          )\n        }\n\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)\n        gl.bindBuffer(gl.ARRAY_BUFFER, null)\n      }\n    }\n\n    for (let i = 0; i < node.children.length; i++) {\n      this.renderNode(\n        node.children[i],\n        activeCamera,\n        activeMaterial,\n        needsMatrixUpdate,\n      )\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}